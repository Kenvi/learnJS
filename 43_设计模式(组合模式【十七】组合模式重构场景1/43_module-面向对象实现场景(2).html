<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>43_module-面向对象实现场景(2)</title>
</head>
<body>
	<script src="../resource/commom.js"></script>
	<script>
		// 组合模式
		/**
		 * 组合模式适用的场景和特点
		 * 场景：
		 * 1 存在一批组织成某种层次体系的对象
		 * 2 希望对这批对象或其中的一部分对象实施一个操作
		 *
		 * 应用特点：
		 * 1 组合模式中只有两种类型对象：组合对象和叶子对象
		 * 2 两种对象都实现同一批接口
		 * 3 一般会在组合对象中调用其方法并隐式调用"下级对象"的方法(采用递归的形式)
		 *
		**/

		/*
		 * 场景模拟
		 *
		 *   -> 公司
		 *             -> 财务
		 *                       -> 张一山
		 *                       -> 张二山
		 *                       -> 张三山
		 *             -> 销售
		 *                       -> 鄣泰明
		 *                       -> 鲁勇横
		 *                       -> 成啸膑
		 *
		 *   实际的任务具体落实到人，只有人才具有具体的方法实现
		 *
		*/

		// 接口实例化
		var CompostieInterface = new CP.Interface('CompostieInterface',['addChild','getChild']);
		var LeafInterface = new CP.Interface('LeafInterface',['hardWorking','sleeping']);

		// 组合对象
		var Compostie = function(name){ 
			this.name = name;
			this.type = 'Compostie'; // 声明类型
			this.children = [];
		};
		Compostie.prototype = {
			constructor : Compostie,
			addChild : function(child){

			},
			getChild : function(name){

			},
			hardWorking : function(name){

			},
			sleeping : function(name){

			}
		};

		// 叶子对象
		var Leaf = function(name){ 
			this.name = name;
			this.type = 'Leaf'; // 声明类型
		};
		Leaf.prototype = {
			constructor : Leaf,
			addChild : function(child){
				throw new Error('This method can not use in Leaf object!');
			},
			getChild : function(name){
				if(this.name = name){
					return this;
				}else{
					return null;
				}
			},
			hardWorking : function(){
				console.log(this.name + ' is working hard!');				
			},
			sleeping : function(){
				console.log(this.name + ' can have a sleep.');
			}
		};
	</script>
</body>
</html>